#define PAGE_SIZE 4096

long user_stack[PAGE_SIZE >> 2];

//在32位Linux平台上，long是4个Byte。所以数组user_stack一共占据  4 * 1024 个 Byte,刚好是一个内存页的大小。

struct{
    long    *a;     //在32位架构下，任何类型的指针都是4个Byte
    short   b;      //2个Byte
} stack_start = { &user_stack[PAGE_SIZE >> 2],0x10 };

//  stack_start是全局变量（具有全局可见性）。它的第一个成员a指向user_stack数组，另一个成员b是0x10

/*
    现在，让我们开始深入讨论这一段代码。
    lss stack_start,%esp            # 设置初始进程所需的栈

    关于栈，首先要明白，在目前的OS设计中，任何一个进程都要用到栈(stack)结构。
    栈本质是一个数组，在逻辑上，栈的元素是后进先出，除此之外没有任何特别之处。
    所以，栈只是简单的一段内存而已。

    SS, SP, BP 三个寄存器是用于描述栈的寄存器。
    SS是栈的段地址，SP是栈顶指针（永远指向栈的顶端）。SS:SP永远指栈顶的真实物理地址。
    BP是一个备用的寄存器，如果想要读取栈的数据，又不想破坏栈顶指针SP，那么可以把SP的值复制一份给BP，用SS:BP的手法来进行处理。

    user_stack是一段内存，它的大小是4KB。我们现在要把它作为初始进程的栈。
    我们需要让SS:SP指向这个数组的尾部元素。因为86的栈是向下增长的，所以要把数组的末尾作为栈顶（一开始栈顶 和 栈底是同一个地方），随着入栈元素越来越多，新元素会越来越接近于数组的下标0位置。

    lss 是设置栈的指令，从stack_start的位置开始，读取6个字节，分别设置ESP寄存器（4Byte）和SS寄存器（2Byte）。
    所以说，经过这条指令后
    SS寄存器 = 0x10, ESP寄存器 = user_stack尾部元素的段内地址（相对地址）。
    所谓的内核，其实也只是一个程序。既然是程序，就有代码段和数据段的划分。而全局变量会被放入数据段，所以user_stack肯定在数据段之内。
    那么SS寄存器内肯定是内核数据段的基地址。
    
    由于我们已经进入了保护模式，所以我们要通过gdt来访问一个段。
    而0x10对应的段正好是内核数据段。

    现在来说说最重要的一点：这条指令到底有什么用呢？
    我们后续用到了push和pop指令，比如push会把一个值存入SS:SP指向的位置，并修改SP指针，
    那么，如果在push之前，我们先修改了SS和SP的值，那么后续使用push时，数据就会如我们所愿地被存入一个特定的位置。
    这个特定的位置，就是我们预先设计好的数组。
*/