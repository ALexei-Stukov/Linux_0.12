BOOTSEG =   0x7c0                   # 记录BOOT段被加载到何处。
                                    # 注意，这是一个“段基地址”，因为这个值最终会被推入“段基地址寄存器”。因此最终，这个值会乘以 0x10，也就是 * 16，或者说 * 2^4。作者在第二章开头点出了这个关键。
                                    # 注意一个逻辑问题：引导程序的加载是由bios完成的。BOOTSEG的功能只是记录了bios预设的加载位置，而不是影响bios的加载流程。

.code16                             # 指定段的格式，.code16意味着这个段的汇编是为16位cpu准备的。
                                    # BOOT段是第一个被运行的段，此时CPU还没有打开保护模式，因此寻址能力有限（不能超过20位）。此时的CPU只能执行.code16格式的汇编代码。
                                    # 后续进入保护模式之后，可以使用.code32或者.code64，编写能适配32位CPU或者64位CPU的段。
                                    # 这种写法一般只会出现在bootloader内。

.text                               # 代码段的起点

.global _start                      # _start 被默认的 链接器ld 脚本用作入口点,虽然可以自定义入口点名称，但是没有去自定义的必要。沿用 _start 就可以。
                                    # 如果不使用 .global _start 把 _start这个符号给导出，连接器ld就无法感知到这个符号，因此链接会失败。

_start:                             # 这里就是_start段，也就是俗称的“BOOT段”。因为.global _start的作用，BOOT段是第一个被运行的段。
    jmpl    $BOOTSEG,   $start2     # 目前_start段还没有做太多事情，只执行一条跳转指令而已。
                                    # jmpl 指的是间接跳转，很多人厌恶这个语法，因为末尾的小写L和long很接近，容易让人迷惑。有不少人喜欢使用 [] 符号来强调间接性。
                                    # 似乎是因为语言的问题，导致直接跳转某些时候不可用，所以会需要jmpl这种语句。
                                    
                                    # 该语句的意思是，执行跳转，令下一条指令 = BOOTSEG[start2]，即 (address of BOOTSEG) + (address of start2)。 
                                    # 其中 (address of BOOTSEG) 是段基地址，它最终将会是0x7c00。
                                    # 而 (address of start2) 是 start2 标记在“本文件内”的位置。这是一个相对位置。
                                    # 通过偏移寻址的手法，我们成功从 段_start 跳进了 段start2。
start2:
    movw    $BOOTSEG,   %ax         
    movw    %ax,        %ds         
    movw    %ax,        %es        
    movw    %ax,        %fs         
    movw    %ax,        %gs         

    movw    $msg,       %ax         # 把变量msg的地址存到寄存器ax内
    movw    %ax,        %bp         # 把寄存器ax的值传递到bp寄存器
    movw    $0x01301,   %ax         # 这个0x01301是特殊的值，它在为中断做准备。
                                    # 设置寄存器ax为0x01301，准备调用BIOS中断10h（视频服务）的功能13h（写字符串），写字符串时使用01h的模式（01h 是指 40×25 16色文本）。

    movw    $0x0c,      %bx         # 设置寄存器bx=0x0c，使得文字为红色
    movw    $38,        %cx         # 设置寄存器cx=0x12,使得字符串长度=38
    
    movb    $9,         %dl         # 设置寄存器dl=0,这里指的是打印字符串的列号。
    movb    $9,         %dh         # 设置寄存器dh=0,这里指的是打印字符串的行号。

    int     $0x010                  # 调用10号中断，通知显卡刷新内容

loop:
    jmp    loop                     # 跳转到loop标记，以此构造出一个无限循环

msg:                                # 以ascii码的形式存储一行字符串,它不能太长，否则可能和扇区尾部的标记互相影响。
.ascii  "Hello World! You are very great! Guys!"

.org    510                         # 一个扇区的大小为512。此处使用伪指令，让下一条指令从510这个地址开始。
                                    # 如果此时再写入一个字节，那么将会被写入到511。

boot_flag:                          # 在扇区的最后两个字节 写入启动标记 0xaa55
    .word  0xaa55

                                    # 这是x86_64架构的引导代码，无法直接适配到其他架构。
                                    # 任何对bios的访问都需要依赖于中断。包括引导程序本身，也是在19号中断之后才会执行的。
                                    # 中断意味着有需求，需要进行响应。以后我们会经常和中断打交道的。

                                    # 为了避免编译器报无所谓的警告，在底部多加几行空行
                                    # 对这个代码执行make进行编译，得到的产物应该是512Byte

                                    


