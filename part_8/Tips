这一部分主要涉及到字符设备。

光有内核没用，还要让内核支持具体设备。
内核是控制中心，设备才是执行功能的具体单元。

这一部分新增了字符设备驱动，完善了对键盘的使用。
同时，文件系统的相关代码第一次出现了。Linux内的哲学是“一切皆文件”，我们可以从早期的原型看出这种思想。

首先要明确键盘的通讯方式：
    键盘内有两个芯片：数据芯片(典型产品是intel 8048芯片)和控制芯片(典型产品是8042芯片)。
    数据芯片负责监听按键并解码，解码会被放到控制芯片内。
    控制芯片会发起中断，让操作系统取走数据。
    所以键盘的数据实际上是一个队列，如果当前数据没有发送完，那么可能无法监听新的按键。只不过现在芯片的主频很高，基本不会遇到这种情况。

    需要注意的是，所谓的“键盘中断”是有说法的。
    如果是远古时代，键盘鼠标以PS2插口连接主板，此时的中断是“硬中断”。它基本无法被阻塞。
    而如今，USB键盘，蓝牙键盘已经很流行了，此时的中断是USB发起的中断，是由操作系统处理的“软中断”。如果操作系统陷入卡顿，键盘和鼠标中断可能会被阻塞。

其次要明确键盘的工作方式：
    键盘是一个字符设备，它需要控制tty。观察kboard.c的函数，它的绝大部分功能都基于tty，绝大部分数据的最终流向都是tty。
    所以，其实这里有一个顺序的区别。
    键盘依赖于tty，而不是tty依赖于键盘。
    其实Linux0.11已经实现了串口等功能，串口也是字符设备，它同样也基于tty。

在Linux内核中，console terminal tty shell 是4个完全不一样的东西。

【TTY】
内核子系统，管理终端会话、行缓冲与设备抽象
tty是主管字符设备的子系统，任何字符设备最终都要和tty交互。
tty本可以实现自己的读写，功能，但是tty选择依赖于系统调用。这是一个很好的解耦手法，也彰显了“一切皆文件”的逻辑。

【Terminal】
用户/硬件设备，提供人机交互的输入输出环境。
terminal是终端，它一般和用户交互的界面有关。可以是纯字符界面，也可以是带图像的界面。它必须要基于tty。

【Shell】
Shell
用户空间进程，解释命令、管理进程与IO重定向。
shell是运行在终端内的软件。它负责解析、执行用户的命令。

【Console】
内核输出通道，内核消息广播与紧急调试接口。
console最特殊。
虽然console看起来像是一个字符设备，但它可以依赖于tty，也可以不依赖于tty。一般为了解耦，会刻意地不去依赖tty。
printk函数打印的消息就在这里。
内核的很多消息都走console，可以认为它不是服务于用户，而是服务于所有进程的“中央tty”。

这里多提一个东西：【ioctl】

read和write只能读写数据，但是对设备的参数配置却无能为力。
举个例子：
从一个端口中传来一些信息，这些信息指出设备即将切换波特率。如果内核不改变波特率，显然无法再收到有效数据。
问题在于，改变设备的工作参数、工作逻辑，这个任务应该由write来完成吗？
绝对不是。
因为write作为posix接口，它的功能很单一，就是写数据。它不适合承担过于广泛的任务。
所以Linus专门用 input/output control来修改设备的状态。
不同的设备都有属于自己的，不同的ioctl。

ioctl的特点如下。
功能定位        设备控制的“后门”机制，补充通用I/O模型的不足
性能影响        上下文切换开销较大，但足够应对低频控制操作
兼容性争议      过于灵活的接口设计需辅以文档和标准化促进