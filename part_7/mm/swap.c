#include <linux/mm.h>

/*
    在mem_map数组中查找第一个空闲页面
    特意使用了汇编代码，这都是为了性能。
*/
unsigned long get_free_page() {
    register unsigned long __res asm("ax") = 0;
    /*
        register - 这是一个存储类说明符，告诉编译器将变量 __res 放在寄存器中
        asm("ax") - 这是 GCC 的扩展语法，指定将变量存储在 ax 寄存器中
        = 0 - 初始化变量值为 0
        
        这个声明的主要作用是：
        创建一个变量 __res，并强制它使用 CPU 的 ax 寄存器
        这通常用于系统调用或底层操作，因为在 x86 架构中，ax 寄存器常用于存储系统调用的返回值
        这种写法允许 C 代码直接控制特定的 CPU 寄存器，这在编写底层系统代码时非常有用
        这种语法通常出现在内核代码中，特别是在需要与汇编代码交互或进行系统调用的场景下。它提供了一种在 C 代码中直接操作特定 CPU 寄存器的方式。
    */

repeat:
    /*
        寄存器EAX初始时被设置为了0。显然寄存器AL（占据1 Byte）也是0。
        PAGING_PAGES是mem_map内的元素数量，它被初始化给了cx寄存器
        mem_map 是一个数组的首地址，mem_map + PAGING_PAGES - 1 是mem_map的末元素的地址。它被初始化给了edi。
    */
__asm__(
        /*
            std用于设置循环方向。
            repne + scasb 用于对比 寄存器AL的内容 和 寄存器EDI指向的内存字节。每次对比都会让EDI减1。
            因为EDI被初始化赋值为了mem_map + PAGING_PAGES - 1，所以这个循环其实就是在反向遍历mem数组。

            如果 EDI指向的内存字节 = AL的内容（也就是0），那么搜索终止，已经找到了空闲的内存页。
            如果 ECX = 0，搜索也将终止。此时说明没有找到。
        */
        "std ; repne ; scasb\n\t"
        /*
            检查是否找到了空闲内存页。如果没有找到，程序将跳转到尾部的标记1,这将导致函数get_free_page() 把 0 给return回去。
        */
        "jne 1f\n\t"

        /*
            在数组中找到了内存页元素，edi目前就指向这个内存页元素。此时 [edi] = 0，
            我们令[edi] = 1，标记这个页面已经被使用。
        */
        "movb $1,1(%%edi)\n\t"
        
        /*
            ecx此时记录着页的id。让id左移12位，再加上可分配内存的最低下限，就可以获得内存页对应的真实物理地址。
            把真实物理地址存入edx寄存器内
        */
        "sall $12, %%ecx\n\t"
        "addl %2, %%ecx\n\t"
        "movl %%ecx, %%edx\n\t"
       
        /*
            在把页表交出去之前，要先清空其中的所有数据。
            设置ecx为循环次数
            设置edi为循环起始地址
            清空eax寄存器，使得eax=0。
            然后执行循环，依次填充eax的值（0）到页表的每一个Byte，一次填充4Byte(32位)。    
        */
        "movl $1024, %%ecx\n\t"
        "leal 4092(%%edx), %%edi\n\t"
        "xor  %%eax, %%eax\n\t"
        "rep; stosl;\n\t"

        /*
            最后把页表的地址保存在 eax 寄存器内，返回给外部。
        */
        "movl %%edx,%%eax\n"
        /*
            这个"1:"是和jne 1f配合的标记。
        */
        "1:"
        :"=a"(__res)                                // 该约束是关于ax寄存器的。返回值要放在ax中，且赋值给__res。
        /*
            ""(0)指的是沿用上一个约束，且初始赋值为0。上一个约束是针对ax的，所以这里的意思是：令ax初始值为0。显然寄存器AL也是0。
            "i"(LOW_MEM) 对应的是代码中 %2 的位置。    
        */
        :""(0), "i"(LOW_MEM), "c"(PAGING_PAGES),    
        "D"(mem_map+PAGING_PAGES-1)                 
        :"dx");

    /*
        要考虑一些奇特的情况，如果指针超出了管理的内存范围，说明分配出现错误，需要重新分配。
        这可能会让程序卡住不动，但是也比带着问题继续运行好得多。
    */
    if (__res >= HIGH_MEMORY)
        goto repeat;
    /*
        返回一个32位指针，指向一个空闲页面的起点地址。
        如果没有空闲页面，这个指针就是0。
    */
    return __res;
}

