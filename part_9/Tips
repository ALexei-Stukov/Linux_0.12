这一部分主要涉及到块设备，而且需要支持软盘和硬盘设备。总体流程和支持字符设备差不多。

首先要给出块设备的抽象驱动，其次是给出具体设备的适配。
对于不同的设备，需要使用不同的中断来处理。

对于块设备，我们同样需要支持read和write接口，以及控制接口ioctl。

基本上来说，进程与硬盘的交互过程是这样的：
进程向硬盘下指令，然后进入休眠。当指令完成，硬盘向CPU发出中断，CPU将唤醒进程。

在这一部分，可以看到Linux对缓冲区的重度使用。
因为io速度和CPU通信速度往往有不止一个数量级的差距，所以必须要使用缓冲区，减少io次数。
对于软盘这种速度极慢的东西，我们还需要DMA。不然就软盘的读写速度，一定会拖累整体效率。
DMA很重要，目前所有高性能网卡都带有DMA芯片。不带DMA的网卡估计只有10M吧。

我第一次看到了内核中的自旋锁，简单又实用。

比较有趣的是：内核使用的不是真实时间。
内核的时间是离散的，每当时钟中断出现，内核的时间就往前增加1。至于时钟中断出现的频率则是可以控制的，当然，一般也不会改变。
所以，计时器的“时长”也不是真实时间，而是“时钟中断的次数”。
若一个计时器的时长=10，那么当Linux内核监听到10个时钟中断之后，这个计时器就会终结。
每个计时器都绑定了一个函数，在计时器终结之后，函数会被执行。
Linux通过这种手法构造出了“定时任务”。

比较可惜的是，由于我的之前的失误，代码出现了一些隐蔽的问题。我构建的镜像无一例外都无法运行。

我拿hinus的代码作比较，实在是找不出问题。
最终我决定从hinus的代码继续探索。